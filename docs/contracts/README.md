# Contract examples

Nibbler reads the governance contract from `.nibbler/contract/` by merging YAML fragments (sorted by filename). The default writer layout is:

- `team.yaml`: roles, sharedScopes, escalationChain
- `phases.yaml`: phases, gates, globalLifetime

These examples are **commented** and intended as learning/reference material.

## Files

- `team.yaml`: example role definitions and scopes
- `phases.yaml`: example phase graph and a PO gate

## Notes

- **Workflow rules**: after `nibbler init` is approved, Nibbler generates and commits a repo-specific workflow rules file at:
  - `.cursor/rules/10-nibbler-workflow.mdc`
  This file is AI-generated from the validated contract (roles/scopes/phases) and is regenerated by `nibbler init --review`.

- **Handoff artifacts (best-effort, all sessions)**: roles are encouraged to write a short continuity note after each session:
  - write: `.nibbler-staging/<jobId>/handoffs/<roleId>-<phaseId>.md`
  - read (materialized): `.nibbler/jobs/<jobId>/plan/handoffs/`

## Gate schema requirements

Every gate definition must include:

- `approvalScope`: one of `phase_output`, `build_requirements`, `both`
- `approvalExpectations`: list of PO-facing expectations
- `businessOutcomes`: business value statements
- `functionalScope`: functional capabilities to deliver
- `outOfScope`: explicit exclusions

For PLAN PO gates (`trigger: "planning->..."`), the contract validator enforces:

- `approvalScope` must be `build_requirements` or `both`
- `requiredInputs` must include `vision.md` and `architecture.md`
- `businessOutcomes` must be non-empty
- `functionalScope` must be non-empty

## Detailed PLAN gate examples

These examples show the intended PO experience: approve what will be built at business/functional level, not just role output formatting.

### Example 1: Web app MVP gate

```yaml
- id: plan
  trigger: "planning->execution"
  audience: "PO"
  approvalScope: "build_requirements"
  approvalExpectations:
    - "Approve MVP scope for appointment booking and reminders."
    - "Approve implementation plan and role delegation."
  businessOutcomes:
    - "Customers can self-book appointments without phone support."
    - "Operations reduce no-show rate through reminder automation."
  functionalScope:
    - "User signup/login with role-based access."
    - "Appointment creation, reschedule, and cancellation."
    - "Automated reminder notifications before appointment time."
  outOfScope:
    - "Payments and invoicing."
    - "Multi-location capacity optimization."
  requiredInputs:
    - { name: "vision", kind: "path", value: "vision.md" }
    - { name: "architecture", kind: "path", value: "architecture.md" }
    - { name: "acceptance", kind: "path", value: ".nibbler/jobs/<id>/plan/acceptance.md" }
  outcomes: { approve: "execution", reject: "planning" }
```

### Example 2: API/service MVP gate

```yaml
- id: plan
  trigger: "planning->execution"
  audience: "PO"
  approvalScope: "build_requirements"
  approvalExpectations:
    - "Approve API MVP scope and external integration boundaries."
    - "Approve validation and rollout strategy."
  businessOutcomes:
    - "Partners can programmatically onboard customers via API."
    - "Manual operations overhead is reduced through automation."
  functionalScope:
    - "Authenticated REST endpoints for create/read/update lifecycle."
    - "Webhook delivery for downstream system synchronization."
    - "Audit logging and basic error observability."
  outOfScope:
    - "GraphQL support."
    - "Advanced analytics dashboards."
  requiredInputs:
    - { name: "vision", kind: "path", value: "vision.md" }
    - { name: "architecture", kind: "path", value: "architecture.md" }
    - { name: "acceptance", kind: "path", value: ".nibbler/jobs/<id>/plan/acceptance.md" }
  outcomes: { approve: "execution", reject: "planning" }
```

### Example 3: CLI tooling MVP gate

```yaml
- id: plan
  trigger: "planning->execution"
  audience: "PO"
  approvalScope: "build_requirements"
  approvalExpectations:
    - "Approve command surface and operator workflow."
    - "Approve execution plan and testing strategy."
  businessOutcomes:
    - "Engineers can bootstrap and validate environments faster."
    - "Operational mistakes are reduced via guided command workflows."
  functionalScope:
    - "Initialize project config with `init` command."
    - "Run deterministic validation checks with `check` command."
    - "Generate machine-readable reports for CI usage."
  outOfScope:
    - "Cloud-hosted control plane."
    - "Plugin marketplace for third-party extensions."
  requiredInputs:
    - { name: "vision", kind: "path", value: "vision.md" }
    - { name: "architecture", kind: "path", value: "architecture.md" }
    - { name: "acceptance", kind: "path", value: ".nibbler/jobs/<id>/plan/acceptance.md" }
  outcomes: { approve: "execution", reject: "planning" }
```

- **Terminal SHIP gate**: you can place a gate *after* the last phase by using a trigger of the form
  `${terminalPhaseId}->__END__` (for example, `ship->__END__`). This allows you to generate final artifacts
  (like `README.md`) and then have the PO approve what was produced.
- **Deterministic README checks**: for a docs-focused SHIP phase, you can require:
  - `artifact_exists(README.md)`
  - `markdown_has_headings` with `requiredHeadings` + `minChars`

### `markdown_has_headings` (deterministic README quality gate)

The `markdown_has_headings` criterion makes README quality enforceable without “AI judgement”.

- **What it checks**:
  - The file exists and is readable.
  - The markdown contains each required heading (case-insensitive; whitespace-normalized).
  - Optional: `minChars` ensures the file isn’t trivially short.
- **How matching works**:
  - Headings are extracted from `# ...` through `###### ...`.
  - Matching is **case-insensitive** and ignores extra whitespace.
  - A required heading is satisfied if a found heading equals it, or **starts with** it (allows e.g. `Install (Linux)` to satisfy `Install`).

### “Green” enforcement (tests must pass)

TDD itself is encouraged via role `behavioralGuidance`, but you can enforce “leave the suite green” deterministically by adding:

- `command_succeeds: npm test`

…to the `execution` phase completion criteria.

### Local run smoke checks (runs locally)

For repos that should boot a local dev server, you can enforce “it actually starts” deterministically with:

- `local_http_smoke`: starts a command, polls a local HTTP URL until it responds (2xx/3xx), then terminates the process.

This is best placed in a terminal `ship` phase so it runs **once at the end**, rather than after every implementation role session.

### Gate inputs can reference job worktree artifacts

Gates often review artifacts generated inside the job’s ephemeral worktree (for example, `README.md` produced during `ship`). Gate input collection searches both the repo root and the active job worktree, so `requiredInputs: { kind: path, value: "README.md" }` works for terminal `ship->__END__` review gates.

